[["index.html", "GMUG National Forests Group Selection Study Chapter 1 Objective", " GMUG National Forests Group Selection Study George Woolsey 2022-11-04 Chapter 1 Objective The objective of this analysis is to describe the site conditions for a group selection treatment on the Grand Mesa Uncompahgre and Gunnison National Forests (GMUG). The study being installed includes different sized group selection openings or reserve groups. This analysis seeks to quantify: the frequency of group opening or reserve group sizes for each of the harvest units. The frequency in each of the opening sizes or reserves within each harvest unit by aspect (the compass direction or azimuth that a terrain surface faces). The shape of the openings sizes in terms of the compass direction that the terrain surface faces with respect to the long axis and short axis This experiment aims to represent group openings with different sizes and the aspects in order to measure differences in light, snow accumulation, and seedling growth. Ideally, sample stratification will be determined by group size and aspect. According to the FACTS Activity Code Description, a Group Selection Cut (code 4152) is: An uneven-aged regeneration method in which trees are cut in small groups and new age classes are established. The width of groups is commonly less than approximately twice the height of the mature trees. Individual trees in the matrix may or may not be harvested to provide improved growing conditions for remaining trees. Multiple entries of this activity ultimately results in an uneven-aged stand of 3 or more age classes. "],["data_prep.html", "Chapter 2 Data Preparation 2.1 National Forest Management data download 2.2 Load Treatment data 2.3 Load Elevation Data 2.4 Load NAIP Imagery 2.5 Treatment Area Aerial View 2.6 Aspect and HLI 2.7 Attach topography and HLI to groups 2.8 Save Data", " Chapter 2 Data Preparation # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) # set crs my_crs &lt;- 5070 # EPSG:5070 = NAD83/Conus Albers (units = meters); EPSG:4326 = WGS 84 (units = dd); EPSG:4269 = NAD83 (units = dd) 2.1 National Forest Management data download The Forest Activity Tracking System (FACTS) database maintained by the U.S. Department of Agriculture, Forest Service (USFS) includes georeferenced boundaries of national forests. # load boundary shapefile forests &lt;- sf::st_read(&quot;../data/forests.gpkg&quot;) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_transform(my_crs) # EPSG:4326 = WGS 84 # keep GMUG gmug &lt;- forests %&gt;% dplyr::filter( forest_commonname %in% c( &quot;Grand Mesa National Forest&quot; , &quot;Uncompahgre National Forest&quot; , &quot;Gunnison National Forest&quot; ) ) %&gt;% sf::st_union() 2.1.1 GMUG Map mapview::mapviewOptions(homebutton = FALSE, basemaps = c(&quot;Esri.WorldTopoMap&quot;)) # &quot;Esri.WorldImagery&quot; mapview::mapview( x = gmug , color = &quot;black&quot; , lwd = 4 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE , map.types = &quot;Esri.WorldTopoMap&quot; # &quot;Esri.WorldImagery&quot; ) 2.2 Load Treatment data ############################ # load shapefiles ############################ shp_import_fn &lt;- function(pth){ # import dta &lt;- sf::st_read(pth) %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_transform(crs = sf::st_crs(forests)) %&gt;% dplyr::mutate(area_m2 = as.numeric(sf::st_area(.))) %&gt;% dplyr::arrange(desc(area_m2)) %&gt;% dplyr::mutate(shape_id = dplyr::row_number()) #rename sf geom column names(dta)[names(dta)==tolower(attr(dta, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(dta) = &quot;geometry&quot; # return return(dta) } # group selection openings openings &lt;- shp_import_fn(&quot;../data/Bald_all_groups_rev.shp&quot;) %&gt;% dplyr::mutate(group = &quot;Openings&quot;) # group selection reserve groups reserves &lt;- shp_import_fn(&quot;../data/Bald_all_Reserve_grps.shp&quot;) %&gt;% dplyr::mutate(group = &quot;Reserves&quot;) # harvest units units &lt;- shp_import_fn(&quot;../data/UnitEstimate.shp&quot;) %&gt;% dplyr::rename(unit_number = unit_numbe) # combine all_groups &lt;- dplyr::bind_rows( openings %&gt;% dplyr::select(shape_id, group, area_m2) , reserves %&gt;% dplyr::select(shape_id, group, area_m2) ) Attach treatment unit number to group and keep the unit with the largest area when a group is located in more than one unit. # attach harvest data to research plots temp_grp_unit &lt;- sf::st_intersection( all_groups %&gt;% dplyr::select(group, shape_id) , units %&gt;% dplyr::select(unit_number) ) %&gt;% dplyr::mutate(area_m2 = as.numeric(sf::st_area(.))) %&gt;% st_set_geometry(NULL) %&gt;% dplyr::arrange(group, shape_id, desc(area_m2)) %&gt;% group_by(group, shape_id) %&gt;% dplyr::mutate(row_number = dplyr::row_number()) %&gt;% dplyr::filter(row_number == 1) %&gt;% dplyr::select( group , shape_id , unit_number ) %&gt;% dplyr::ungroup() # join to spatial data all_groups &lt;- all_groups %&gt;% left_join(temp_grp_unit, by = c(&quot;group&quot;=&quot;group&quot;, &quot;shape_id&quot;=&quot;shape_id&quot;)) 2.2.1 Group summary statistics #summary all_groups %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(group) %&gt;% dplyr::summarise( N = n() , mean_area = mean(area_m2, na.rm = T) , min_area = min(area_m2, na.rm = T) , max_area = max(area_m2, na.rm = T) ) %&gt;% kableExtra::kable( caption = &quot;Summary statistics by group type&quot; , col.names = c( &quot;Group Type&quot; , &quot;n&quot; , &quot;Mean Area (m sq.)&quot; , &quot;Min. Area (m sq.)&quot; , &quot;Max. Area (m sq.)&quot; ) ) %&gt;% kableExtra::kable_styling(font_size = 12) %&gt;% kableExtra::column_spec(1, bold = TRUE, width = &quot;18em&quot;) Table 2.1: Summary statistics by group type Group Type n Mean Area (m sq.) Min. Area (m sq.) Max. Area (m sq.) Openings 182 3848.606 885.2734 8844.593 Reserves 90 3805.903 1404.9863 8248.804 2.2.2 Group sizes all_groups %&gt;% sf::st_set_geometry(NULL) %&gt;% ggplot( data = . , mapping = aes(x = area_m2, group = group) ) + geom_histogram( aes(y = ..density.., fill = group) , bins = 15 , color = &quot;gray25&quot; ) + facet_grid(group~.) + scale_x_continuous(breaks = scales::extended_breaks(n=10), labels = scales::comma) + scale_fill_manual(values = c(&quot;gray80&quot;, &quot;black&quot;)) + xlab(latex2exp::TeX(&quot;area $m^2$&quot;)) + ylab(&quot;Density&quot;) + labs( title = &quot;Group Area Histogram&quot; ) + theme_bw() + theme( legend.position = &quot;none&quot; ) 2.2.3 GMUG and treatment area map ggplot() + geom_sf( data = gmug , alpha = 0 , lwd = 1, color = &quot;black&quot; ) + geom_sf( data = units %&gt;% sf::st_union() %&gt;% sf::st_buffer(dist = 500) , fill = &quot;royalblue&quot; , lwd = NA ) + labs( title = &quot;GMUG boundary and treatment area in blue&quot; ) + theme_bw() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) 2.2.4 Treatment units map ggplot(data = units) + geom_sf( mapping = aes(fill = unit_number) , lwd = 0.8, color = &quot;black&quot; ) + geom_sf_label( mapping = aes(label = unit_number) , label.padding = unit(0.1, &quot;lines&quot;) , label.size = 0.1 ) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.4) + labs( title = &quot;Harvest treatment units&quot; ) + theme_bw() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) 2.2.5 Treatment units and group map ggplot() + geom_sf( data = units , mapping = aes(fill = unit_number) , lwd = 0.8, color = &quot;black&quot; ) + geom_sf(data = openings, fill = &quot;white&quot;, color = &quot;firebrick&quot;, lwd = 1) + geom_sf(data = reserves, fill = &quot;black&quot;, color = &quot;black&quot;) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.4) + labs( title = &quot;Harvest treatment units and groups&quot; , subtitle = &quot;Reserves = black, Openings = white&quot; ) + theme_bw() + theme( legend.position = &quot;none&quot; , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) 2.2.6 Treatment Units Summary of Groups all_groups %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(unit_number, group) %&gt;% dplyr::summarise( count_groups = n() , total_group_area_m2 = sum(area_m2, na.rm = TRUE) , mean_group_area_m2 = mean(area_m2, na.rm = TRUE) ) %&gt;% dplyr::group_by(unit_number) %&gt;% dplyr::mutate(n = sum(count_groups)) %&gt;% dplyr::arrange(desc(n)) %&gt;% ggplot(.) + geom_col(aes(y = reorder(unit_number, n), x = count_groups, fill = group), width = 0.7) + geom_text( aes(y = reorder(unit_number, n), x =n, label = scales::comma(n, accuracy = 1)) , color = &quot;black&quot;, size = 4 , position = position_dodge(0.9) , hjust = -0.1 ) + labs( title = &quot;Number of Groups in each Treatment Unit by type&quot; ) + xlab(&quot;# Groups&quot;) + ylab(&quot;Treatment Unit Number&quot;) + scale_x_continuous(labels = scales::comma) + scale_fill_manual(values = c(&quot;gray80&quot;, &quot;black&quot;)) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() , axis.text.y = element_text(size = 13) ) 2.3 Load Elevation Data The function elevatr::get_elev_raster was used to obtain a digital elevation model (DEM) raster (~6.8m resolution). ####################################################### ####################################################### # read elevation data ####################################################### ####################################################### if(file.exists(&quot;../data/elev.tif&quot;) == FALSE){ # z =14 is highest resolution (~6.8m) elev &lt;- elevatr::get_elev_raster( locations = units %&gt;% sf::st_union() %&gt;% sf::st_buffer(dist = 2000) , z = 14 ) %&gt;% stars::st_as_stars() %&gt;% setNames(&quot;elev&quot;) # save stars::write_stars(elev, &quot;../data/elev.tif&quot;, append = FALSE) }else{ elev &lt;- stars::read_stars(&quot;../data/elev.tif&quot;) } elev_small &lt;- elev[ units %&gt;% # dplyr::slice_head(n=1) %&gt;% ## testing sf::st_union() %&gt;% sf::st_buffer(dist = 1000) %&gt;% # sf::st_buffer(dist = 1) %&gt;% ## testing sf::st_bbox() ] 2.4 Load NAIP Imagery Download NAIP Imagery from this respository tifs &lt;- list.files(&quot;../data/naip/&quot;, pattern = &quot;\\\\.tif$&quot;, full.names = TRUE) naip_st &lt;- stars::read_stars(tifs[1]) # plot(naip_st) # crop naip_st &lt;- naip_st %&gt;% sf::st_crop( elev_small %&gt;% sf::st_bbox() ) %&gt;% setNames(&quot;value&quot;) %&gt;% dplyr::mutate(value = ifelse(is.na(value), 0, value)) ################### # ggplot prep ################### # set rgb image for ggplot # band 3 = red, band 2 = green, band 1 = blue naip_rgb &lt;- stars::st_rgb( # naip_st[,,,1:3] # CIR naip_st[,,,3:1] # RGB , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) ################### # rayshader prep ################### # FUNCTION to wrangle RGB data to work with rayshader wrangle_rgb &lt;- function(x){ # Load color imagery from Sentinel 2 temp_rgb &lt;- raster::stack(x) %&gt;% raster::crop( elev_small %&gt;% sf::st_bbox() ) # The array must be transposed since rasters and arrays are oriented # differently in R. aperm() is used to perform a multi-dimensional transpose. r_mat = rayshader::raster_to_matrix(temp_rgb[[3]]) g_mat = rayshader::raster_to_matrix(temp_rgb[[2]]) b_mat = rayshader::raster_to_matrix(temp_rgb[[1]]) # create array rgb_array = array(0, dim = c(nrow(r_mat),ncol(r_mat),3)) rgb_array[,,1] = r_mat/255 #Red layer rgb_array[,,2] = g_mat/255 #Blue layer rgb_array[,,3] = b_mat/255 #Green layer # Array Transposition rgb_array = aperm(rgb_array, c(2,1,3)) # enhance contrast scales::rescale(rgb_array, to=c(0.005, 0.995)) return(rgb_array) } # Prepare rgb image overlay rgb_img &lt;- wrangle_rgb(tifs[1]) # stars to matrix for passing to rayshader elev_mat &lt;- starsExtra::layer_to_matrix(elev_small) 2.5 Treatment Area Aerial View 2.5.1 Aerial View - Topography Define topography map and basemap. # on the fly view without setting up basemap topo_plot &lt;- elev_mat %&gt;% rayshader::sphere_shade(sunangle = 78, texture = &quot;desert&quot;) %&gt;% rayshader::add_overlay( rayshader::generate_polygon_overlay( units , extent = methods::as(elev_small, &quot;Raster&quot;) %&gt;% raster::extent() , heightmap = elev_mat , data_column_fill = NULL , palette = &quot;transparent&quot; , linecolor = &quot;white&quot; , linewidth = 5 ) ) # define basemap for going with rgb basemap &lt;- elev_mat %&gt;% # rayshader::sphere_shade(sunangle = 78, texture = &quot;desert&quot;) %&gt;% rayshader::height_shade( # white/gray palette to overlay sat imagery on. Adds some texture without # tinting the color of the output image texture = (grDevices::colorRampPalette(c(&quot;gray60&quot;, &quot;#FFFFFF&quot;)))(256) ) %&gt;% rayshader::add_overlay( rayshader::sphere_shade( elev_mat , texture = &quot;bw&quot; , zscale = 10 , colorintensity = 5 ) , alphalayer = 0.6 ) Plot topography map. # plot topo_plot %&gt;% # rayshader::plot_map() rayshader::plot_3d( elev_mat , zscale = 10 , theta = 30 , phi = 45 , fov = 0 , zoom = 1 # , windowsize = c(1000, 800) ) 2.5.2 Aerial View - RGB Define feature map. # overlay rgb feature_map &lt;- basemap %&gt;% rayshader::add_overlay( rgb_img , alphalayer = .98 ) %&gt;% rayshader::add_overlay( rayshader::generate_polygon_overlay( units , extent = methods::as(elev_small, &quot;Raster&quot;) %&gt;% raster::extent() , heightmap = elev_mat , data_column_fill = NULL , palette = &quot;transparent&quot; , linecolor = &quot;white&quot; , linewidth = 5 ) ) Plot feature map. feature_map %&gt;% # rayshader::plot_map() rayshader::plot_3d( elev_mat , zscale = 10 , theta = 30 , phi = 45 , fov = 0 , zoom = 1 # , windowsize = c(1000, 800) ) 2.6 Aspect and HLI Aspect of a slope (the direction or azimuth that a slope faces) strongly influences potential direct incident radiation and temperature. Untransformed, aspect is a poor variable for quantitative analysis, since 1° is adjacent to 360°  the numbers are very different even though the aspect is about the same. The following equation for Heat Load Index (HLI) rescales aspect to a scale of zero to one, with zero being the coolest slope (northeast) and one being the warmest slope (southwest). HLI is a proxy for aspect-driven solar heating. \\[ \\textrm{Heat load index} = \\frac{1 - \\cos(\\theta - 45)}{2} \\] where \\(\\theta\\) = aspect in degrees east of north. While this and related equations are useful, they do not consider the steepness of the slope. For example, a 1° south-facing slope would receive the same heat load index as a 30° south-facing slope, even though the latter will be considerably warmer. HLI calculations have been developed which combine slope, folded aspect (i.e., southwestness), and latitude to estimate terrain-driven solar heating at a given location (McCune &amp; Keon 2002: eq. 2). To calculate HLI, we used equation 2 of McCune &amp; Keon 2002: eq. 2. Following calculation, we aggregated these data to each group selection boundary (median HLI of ~6.8m pixels). Higher values of HLI are typical on steep southwesterly slopes, while low values are common on steep northeasterly slopes. Moderate values are common in flatter terrain and on northwesterly and southeasterly aspects. Aspect must first be folded about the north-south line, rescaling 0-360° to 0-180°, such that NE = NW, E = W, etc: \\[ \\textrm{Folded aspect°} = 180° \\, - \\, | Aspect°  180° | \\] if(file.exists(&quot;../data/topo.RDS&quot;) == TRUE &amp; overwrite_it == FALSE){ topo &lt;- readRDS(&quot;../data/topo.RDS&quot;) }else{ # extract latitude degrees from stars object lats &lt;- sf::st_coordinates(elev_small) %&gt;% sf::st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;), crs = my_crs) %&gt;% sf::st_transform(crs = 4326) %&gt;% sf::st_coordinates() %&gt;% dplyr::as_tibble() %&gt;% setNames(c(&quot;longitude&quot;,&quot;latitude&quot;)) %&gt;% dplyr::select(latitude) # hli function # This equation returns ln(Rad, MJ · cm2 · yr1). It can # be returned to an arithmetic scale with the EXP(x) # function. hli_fn &lt;- function(slope_rad, folded_aspect_rad, latitude_rad){ exp( (-1*1.236) + 1.350*cos(latitude_rad)*cos(slope_rad) + (-1*1.376)*cos(folded_aspect_rad)*sin(slope_rad)*sin(latitude_rad) + (-1*0.331)*sin(latitude_rad)*sin(slope_rad) + 0.375*sin(folded_aspect_rad)*sin(slope_rad) ) } # calculate slope and aspect from DEM topo &lt;- c( elev_small , starsExtra::slope(elev_small) , starsExtra::aspect(elev_small) ) %&gt;% setNames( c(&quot;elev&quot;, &quot;slope_deg&quot;, &quot;aspect_deg&quot;) ) %&gt;% dplyr::mutate( slope_rad = pracma::deg2rad(as.numeric(slope_deg)) , aspect_rad = pracma::deg2rad(as.numeric(aspect_deg)) , folded_aspect_deg = 180 - abs(as.numeric(aspect_deg)-180) , folded_aspect_rad = pracma::deg2rad(folded_aspect_deg) , latitude_deg = lats$latitude , latitude_rad = pracma::deg2rad(as.numeric(latitude_deg)) , hli = dplyr::case_when( hli_fn(slope_rad, folded_aspect_rad, latitude_rad) &gt; 1 ~ 1 , hli_fn(slope_rad, folded_aspect_rad, latitude_rad) &lt; 0 ~ 0 , TRUE ~ hli_fn(slope_rad, folded_aspect_rad, latitude_rad) ) ) } 2.6.1 Topography maps # map vars &lt;- c( &quot;elev&quot; , &quot;slope_deg&quot; , &quot;aspect_deg&quot; , &quot;folded_aspect_deg&quot; , &quot;hli&quot; ) vars_title &lt;- c( &quot;Elevation (m)&quot; , &quot;Slope (\\u00B0)&quot; , &quot;Aspect (\\u00B0)&quot; , &quot;Folded Aspect (\\u00B0)&quot; , &quot;Heat Load Index (HLI)&quot; ) vars_color &lt;- c( &quot;viridis&quot; , &quot;cividis&quot; , &quot;inferno&quot; , &quot;plasma&quot; , &quot;turbo&quot; ) vars_llim &lt;- c( min(topo$elev, na.rm=T)*.95 , 0 , 0 , 0 , 0 ) vars_ulim &lt;- c( max(topo$elev, na.rm=T)*1.05 , max(as.numeric(topo$slope_deg), na.rm=T)*1.05 , 360 , 180 , 1 ) # plts &lt;- list() plt_fn &lt;- function(x){ ( ggplot() + stars::geom_stars(data = (topo %&gt;% dplyr::select(vars[x]))[]) + scale_fill_viridis_c(option = vars_color[x], alpha = 0.9, na.value = &quot;transparent&quot; , limits = c(vars_llim[x], vars_ulim[x]) ) + geom_sf(data = units, alpha = 0, lwd = 1, color = &quot;black&quot;) + labs( title = vars_title[x] , fill = vars_title[x] ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.text = element_text(size = 7) , legend.title = element_text(size = 7) , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) ) } # combine plots # cowplot::plot_grid(plotlist = plts, ncol = 2) c(1:length(vars)) %&gt;% purrr::map(plt_fn) 2.7 Attach topography and HLI to groups Each group will be assigned the median value of HLI within the group boundary. if(file.exists(&quot;../data/all_groups_topo.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ all_groups_topo &lt;- sf::st_read(&quot;../data/all_groups_topo.gpkg&quot;) }else{ # functions to aggregate raster data to vector data topo_calc_fn &lt;- function(dta){ # calculate median aspect and slope by vector temp_slope &lt;- aggregate(topo %&gt;% dplyr::select(slope_rad), dta, median) %&gt;% dplyr::as_tibble() %&gt;% dplyr::select(slope_rad) temp_aspect &lt;- aggregate(topo %&gt;% dplyr::select(aspect_rad), dta, median) %&gt;% dplyr::as_tibble() %&gt;% dplyr::select(aspect_rad) temp_folded_aspect &lt;- aggregate(topo %&gt;% dplyr::select(folded_aspect_rad), dta, median) %&gt;% dplyr::as_tibble() %&gt;% dplyr::select(folded_aspect_rad) temp_hli &lt;- aggregate(topo %&gt;% dplyr::select(hli), dta, median) %&gt;% dplyr::as_tibble() %&gt;% dplyr::select(hli) # vector center temp_center &lt;- sf::st_centroid(dta)$geometry %&gt;% sf::st_transform(crs = 4326) %&gt;% sf::st_coordinates() %&gt;% dplyr::as_tibble() %&gt;% setNames(c(&quot;longitude&quot;,&quot;latitude&quot;)) %&gt;% dplyr::select(latitude) # attach to input data new_dta &lt;- dta %&gt;% dplyr::mutate( # radians slope_rad = temp_slope$slope_rad , aspect_rad = temp_aspect$aspect_rad , folded_aspect_rad = temp_folded_aspect$folded_aspect_rad , latitude_rad = pracma::deg2rad(as.numeric(temp_center$latitude)) # degrees , slope_deg = pracma::rad2deg(temp_slope$slope_rad) , aspect_deg = pracma::rad2deg(temp_aspect$aspect_rad) , folded_aspect_deg = pracma::rad2deg(temp_folded_aspect$folded_aspect_rad) , latitude_deg = as.numeric(temp_center$latitude) # hli , hli = temp_hli$hli ) return(new_dta) } # apply to data all_groups_topo &lt;- all_groups %&gt;% topo_calc_fn() } 2.7.1 Example group and topography plt_grp_fn &lt;- function(x){ temp_dta &lt;- all_groups_topo %&gt;% dplyr::filter(group == &quot;Openings&quot;) %&gt;% dplyr::slice_head(n = 1) return( ggplot() + stars::geom_stars(data = (topo %&gt;% dplyr::select(vars[x]))[ temp_dta %&gt;% sf::st_buffer(dist = 30) ]) + scale_fill_viridis_c(option = vars_color[x], alpha = 0.9, na.value = &quot;transparent&quot; , limits = c(vars_llim[x], vars_ulim[x]) ) + geom_sf(data = temp_dta , alpha = 0, lwd = 1.1, color = &quot;black&quot; ) + labs( title = paste0(&quot;Example group (area = &quot; , scales::comma(temp_dta$area_m2, accuracy = 1) , &quot; m sq.)&quot; ) , subtitle = vars_title[x] , fill = vars_title[x] ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.text = element_text(size = 7) , legend.title = element_text(size = 7) , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) ) } c(1:length(vars)) %&gt;% purrr::map(plt_grp_fn) 2.8 Save Data if(overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ # write data sf::st_write(all_groups_topo, &quot;../data/all_groups_topo.gpkg&quot;, append = FALSE) sf::st_write(units, &quot;../data/units.gpkg&quot;, append = FALSE) stars::write_stars(topo, &quot;../data/topo.tif&quot;, append = FALSE) saveRDS(topo, &quot;../data/topo.RDS&quot;, compress = TRUE) } "],["analysis.html", "Chapter 3 Analysis of HLI 3.1 Load Data 3.2 Set up base map 3.3 Spatial groups and HLI 3.4 Summary of groups and HLI 3.5 Quartiles of HLI 3.6 Map Cool and Warm Sites 3.7 Characteristics of Cool-Warm Sites 3.8 Length:Width ratio of group selection shape 3.9 Map Group Shape Orientation 3.10 Save Data", " Chapter 3 Analysis of HLI # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) 3.1 Load Data Spatial data was loaded and cleaned in prior chapter. # read topo &lt;- readRDS(&quot;../data/topo.RDS&quot;) all_groups_topo &lt;- sf::st_read(&quot;../data/all_groups_topo.gpkg&quot;) units &lt;- sf::st_read(&quot;../data/units.gpkg&quot;) 3.2 Set up base map # map vars &lt;- c( &quot;elev&quot; , &quot;slope_deg&quot; , &quot;aspect_deg&quot; , &quot;folded_aspect_deg&quot; , &quot;hli&quot; ) vars_title &lt;- c( &quot;Elevation (m)&quot; , &quot;Slope (\\u00B0)&quot; , &quot;Aspect (\\u00B0)&quot; , &quot;Folded Aspect (\\u00B0)&quot; , &quot;Heat Load Index (HLI)&quot; ) vars_color &lt;- c( &quot;viridis&quot; , &quot;cividis&quot; , &quot;inferno&quot; , &quot;plasma&quot; , &quot;turbo&quot; ) vars_llim &lt;- c( min(topo$elev, na.rm=T)*.95 , 0 , 0 , 0 , 0 ) vars_ulim &lt;- c( max(topo$elev, na.rm=T)*1.05 , max(as.numeric(topo$slope_deg), na.rm=T)*1.05 , 360 , 180 , 1 ) # plts &lt;- list() plt_fn &lt;- function(x){ ( ggplot() + stars::geom_stars(data = (topo %&gt;% dplyr::select(vars[x]))[]) + scale_fill_viridis_c(option = vars_color[x], alpha = 0.9, na.value = &quot;transparent&quot; , limits = c(vars_llim[x], vars_ulim[x]) ) + geom_sf(data = units, alpha = 0, lwd = 1, color = &quot;black&quot;) + labs( title = vars_title[x] , fill = vars_title[x] ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.text = element_text(size = 7) , legend.title = element_text(size = 7) , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) ) } 3.3 Spatial groups and HLI See this section for discussion on HLI. HLI is a proxy for aspect-driven solar heating. Higher values (i.e. closer to 1) represent warmer conditions while lower values (i.e. closer to 0) represent cooler conditions. # load basemap hli_basemap &lt;- plt_fn(which(vars==&quot;hli&quot;)) # openings hli_basemap + geom_sf( data = all_groups_topo %&gt;% dplyr::filter(group == &quot;Openings&quot;) , fill = &quot;white&quot; , color = &quot;firebrick&quot; , lwd = 0.5 ) + geom_sf( data = all_groups_topo %&gt;% dplyr::filter(group == &quot;Reserves&quot;) , fill = &quot;black&quot; , color = &quot;black&quot; ) + labs( subtitle = &quot;Reserves = black, Openings = white&quot; ) 3.4 Summary of groups and HLI #summary all_groups_topo %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(group) %&gt;% dplyr::summarise( N = n() , mean_hli = mean(hli, na.rm = T) , min_hli = min(hli, na.rm = T) , max_hli = max(hli, na.rm = T) , hli_25 = quantile(hli, 0.25) , hli_75 = quantile(hli, 0.75) ) %&gt;% kableExtra::kable( caption = &quot;Summary statistics by group type&quot; , col.names = c( &quot;Group Type&quot; , &quot;# Groups&quot; , &quot;Mean HLI&quot; , &quot;Min. HLI&quot; , &quot;Max. HLI&quot; , &quot;25% HLI&quot; , &quot;75% HLI&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling(font_size = 12) %&gt;% kableExtra::column_spec(1, bold = TRUE, width = &quot;18em&quot;) Table 3.1: Summary statistics by group type Group Type # Groups Mean HLI Min. HLI Max. HLI 25% HLI 75% HLI Openings 182 0.80 0.56 0.97 0.72 0.87 Reserves 90 0.83 0.64 0.98 0.81 0.87 3.5 Quartiles of HLI all_groups_topo_fnl &lt;- all_groups_topo %&gt;% dplyr::group_by(group) %&gt;% dplyr::mutate( hli_group_percent_rank = dplyr::percent_rank(hli) , hli_group_qrtl = dplyr::case_when( hli_group_percent_rank &lt;= .25 ~ &quot;Coolest&quot; , hli_group_percent_rank &lt;= .5 ~ &quot;Med. Cool&quot; , hli_group_percent_rank &lt;= .75 ~ &quot;Med. Warm&quot; , hli_group_percent_rank &lt;= 1 ~ &quot;Warmest&quot; , TRUE ~ &quot;ERROR&quot; ) ) %&gt;% dplyr::mutate( hli_group_qrtl = factor( hli_group_qrtl , ordered = TRUE , levels = c(&quot;Coolest&quot;, &quot;Med. Cool&quot;, &quot;Med. Warm&quot;, &quot;Warmest&quot;) ) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( hli_overall_percent_rank = dplyr::percent_rank(hli) , hli_overall_qrtl = dplyr::case_when( hli_overall_percent_rank &lt;= .25 ~ &quot;Coolest&quot; , hli_overall_percent_rank &lt;= .5 ~ &quot;Med. Cool&quot; , hli_overall_percent_rank &lt;= .75 ~ &quot;Med. Warm&quot; , hli_overall_percent_rank &lt;= 1 ~ &quot;Warmest&quot; , TRUE ~ &quot;ERROR&quot; ) ) %&gt;% dplyr::mutate( hli_overall_qrtl = factor( hli_overall_qrtl , ordered = TRUE , levels = c(&quot;Coolest&quot;, &quot;Med. Cool&quot;, &quot;Med. Warm&quot;, &quot;Warmest&quot;) ) ) %&gt;% sf::st_make_valid() sf::st_write(all_groups_topo_fnl, &quot;../data/all_groups_topo_fnl.gpkg&quot;, append = FALSE) 3.5.1 HLI Quartiles by treatment type all_groups_topo_fnl %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(group, hli_group_qrtl) %&gt;% dplyr::summarise( mean_hli = mean(hli, na.rm = T) ) %&gt;% ggplot(.) + geom_col(mapping = aes(y = mean_hli, x = hli_group_qrtl, fill = group), width = 0.7) + geom_text( aes(x = hli_group_qrtl, y = mean_hli, label = scales::comma(mean_hli, accuracy = .01)) , color = &quot;black&quot;, size = 4 , position = position_dodge(0.9) , vjust = -0.1 ) + facet_grid(.~group) + labs( title = &quot;Mean HLI of Groups by treatement for cool-warm sites&quot; ) + xlab(&quot;Cool-Warm Site&quot;) + ylab(&quot;Mean HLI&quot;) + scale_fill_manual(values = c(&quot;gray80&quot;, &quot;black&quot;)) + theme_bw() + theme( legend.position = &quot;none&quot; ) There is a difference in the mean HLI for the cool and medium cool groups across the opening and reserve treatments. 3.5.2 HLI Quartiles overall temp_dta &lt;- all_groups_topo_fnl %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(hli_overall_qrtl) %&gt;% dplyr::summarise( mean_hli = mean(hli, na.rm = T) , n = n() ) %&gt;% dplyr::mutate(nlab = paste0(&quot;n=&quot;,n)) ggplot(temp_dta) + geom_col(mapping = aes(y = mean_hli, x = hli_overall_qrtl), fill = &quot;navy&quot;, width = 0.7) + geom_text( aes(x = hli_overall_qrtl, y = mean_hli, label = scales::comma(mean_hli, accuracy = .01)) , color = &quot;black&quot;, size = 4 , position = position_dodge(0.9) , vjust = -0.7 ) + geom_text( aes(x = hli_overall_qrtl, y = mean_hli, label = nlab) , color = &quot;black&quot;, size = 2.5 , position = position_dodge(0.9) , vjust = -0.1 ) + labs( title = &quot;Mean HLI of Groups by treatement for cool-warm sites&quot; ) + xlab(&quot;Cool-Warm Site&quot;) + ylab(&quot;Mean HLI&quot;) + scale_fill_manual(values = c(&quot;gray80&quot;, &quot;black&quot;)) + theme_bw() + theme( legend.position = &quot;none&quot; ) 3.5.3 Counts by cool-warm and treatment group all_groups_topo_fnl %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(group, hli_overall_qrtl) %&gt;% dplyr::summarise(n = n()) %&gt;% ggplot(.) + geom_bar(aes(x = hli_overall_qrtl, y = n, fill = group, label = n) , stat = &quot;identity&quot;, width = 0.7) + geom_text(aes(x = hli_overall_qrtl, y = n, fill = group, label = n) , size = 4, position = position_stack(vjust = 0.5), color = &quot;white&quot;) + geom_text(data = temp_dta , aes(x = hli_overall_qrtl, y = n, label = n) , color = &quot;black&quot;, size = 5 , position = position_dodge(0.9) , vjust = -0.2 ) + labs( title = &quot;Count of treatment groups for cool-warm sites&quot; ) + xlab(&quot;Cool-Warm Site&quot;) + ylab(&quot;Count Groups&quot;) + scale_fill_manual(values = c(&quot;gray80&quot;, &quot;black&quot;)) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() ) 3.6 Map Cool and Warm Sites p_hli_fn &lt;- function(x){ ggplot() + geom_sf( data = units , lwd = 0.8 , alpha = 0 , color = &quot;black&quot; ) + geom_sf( data = all_groups_topo_fnl %&gt;% dplyr::filter(group == x) , aes(fill = hli_overall_qrtl) , lwd = 0 ) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.9) + labs( title = paste(x, &quot;- Heat Load Index&quot;) , subtitle = &quot;harvest treatment units in black&quot; ) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) } c(unique(all_groups_topo_fnl$group)) %&gt;% purrr::map(p_hli_fn) 3.7 Characteristics of Cool-Warm Sites 3.7.1 Summary statistics # vars to aggregate vars_temp &lt;- c( &quot;hli&quot; , &quot;area_m2&quot; ) vars_lab_temp &lt;- c( &quot;HLI&quot; , latex2exp::TeX(&quot;Area ($m^{2}$)&quot;) ) # aggregate data to daily level # named list of functions summary_fns &lt;- list( mean = ~mean(.x, na.rm = TRUE) # , median = ~median(.x, na.rm = TRUE) , min = ~min(.x, na.rm = TRUE) , max = ~max(.x, na.rm = TRUE) # , N = ~sum(ifelse(is.na(.x), 0, 1)) ) all_groups_topo_fnl %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(hli_overall_qrtl) %&gt;% dplyr::summarise( dplyr::across( tidyselect::all_of(vars_temp) , summary_fns , .names = &quot;{.col}_{.fn}&quot; ) ) %&gt;% dplyr::ungroup() %&gt;% kableExtra::kable( caption = &quot;Summary statistics by group type&quot; , col.names = c( &quot;&quot; , &quot;Mean HLI&quot; , &quot;Min. HLI&quot; , &quot;Max. HLI&quot; , &quot;Mean Area m sq.&quot; , &quot;Min. Area m sq.&quot; , &quot;Max. Area m sq.&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling(font_size = 12) %&gt;% kableExtra::column_spec(1, bold = TRUE, width = &quot;18em&quot;) 3.7.2 HLI and Area Distribution p_fn &lt;- function(my_var) { ( ggplot() + geom_density(data = all_groups_topo_fnl, mapping = aes_string(x = my_var, fill = &quot;hli_overall_qrtl&quot;) , color = NA ) + facet_grid(hli_overall_qrtl~.) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.9) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + xlab(vars_lab_temp[which(vars_temp == my_var)]) + ylab(&quot;Density&quot;) + labs( title = vars_lab_temp[which(vars_temp == my_var)] , subtitle = &quot;distribution by cool-warm site type&quot; ) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) ) } # call function vars_temp %&gt;% purrr::map(p_fn) 3.7.3 HLI and Area Scatter ggplot(data = all_groups_topo_fnl) + geom_point( mapping = aes( x = hli , y = area_m2 , color = hli_overall_qrtl ) ) + scale_color_viridis_d(option = &quot;turbo&quot;, alpha = 0.9) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + scale_y_continuous(breaks = scales::extended_breaks(n=10), labels = scales::comma) + xlab(&quot;HLI&quot;) + ylab(latex2exp::TeX(&quot;Area ($m^{2}$)&quot;)) + labs( title = latex2exp::TeX(&quot;HLI and Area ($m^{2}$)&quot;) ) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() ) + guides(color = guide_legend(override.aes = list(size = 5))) 3.8 Length:Width ratio of group selection shape Using a simple length:width ratio to determine the orientation of the group selection shape results in a ratio that is unbounded (e.g. \\(10^{-\\infty} \\; \\textrm{to} \\; 10^{+\\infty}\\)) given very small values of length versus very large values of width and vice versa. Below we define a north-south shape orientation index where the metric is centered at 0.5 (length:width = 1:1) with a minimum value of 0 (length:width = 0:1) and a maximum value of 1 (length:width = 1:0). Values above 0.5 indicate shapes with more north-south orientation, values less than 0.5 indicate more east-west orientation, and values near 0.5 indicate more square shape (e.g. equal N-S and E-W orientation). # get bbox output as data frame for (i in 1:nrow(all_groups_topo_fnl)){ dta_temp &lt;- data.frame( shape_id = all_groups_topo_fnl$shape_id[i] , group = all_groups_topo_fnl$group[i] , xmin = sf::st_bbox(all_groups_topo_fnl$geom[i])[1] , xmax = sf::st_bbox(all_groups_topo_fnl$geom[i])[3] , ymin = sf::st_bbox(all_groups_topo_fnl$geom[i])[2] , ymax = sf::st_bbox(all_groups_topo_fnl$geom[i])[4] ) if(i==1){ dta_join_temp &lt;- dta_temp }else{ dta_join_temp &lt;- rbind(dta_join_temp, dta_temp) } remove(dta_temp) } # join to main data all_groups_topo_fnl &lt;- all_groups_topo_fnl %&gt;% dplyr::left_join(dta_join_temp, by=c(&quot;shape_id&quot;=&quot;shape_id&quot;, &quot;group&quot;=&quot;group&quot;)) %&gt;% dplyr::mutate( xlength_m = xmax - xmin , ylength_m = ymax - ymin , length_width_ratio = ylength_m / xlength_m , north_south_orientation_index = ylength_m / (xlength_m+ylength_m) , orientation_class = dplyr::case_when( north_south_orientation_index &lt; 0.4 ~ &quot;More E-W&quot; , north_south_orientation_index &lt;= .6 ~ &quot;Square&quot; , north_south_orientation_index &lt;= 1 ~ &quot;More N-S&quot; , TRUE ~ &quot;ERROR&quot; ) # , lw_class = dplyr::case_when( # length_width_ratio &lt; 2/3 ~ &quot;More E-W&quot; # , length_width_ratio &lt;= 3/2 ~ &quot;Square&quot; # , length_width_ratio &lt;= 1e+12 ~ &quot;More N-S&quot; # , TRUE ~ &quot;ERROR&quot; # ) ) %&gt;% dplyr::mutate( orientation_class = factor( orientation_class , ordered = TRUE , levels = c(&quot;More E-W&quot;, &quot;Square&quot;, &quot;More N-S&quot;) ) # , lw_class = factor( # lw_class # , ordered = TRUE # , levels = c(&quot;More E-W&quot;, &quot;Square&quot;, &quot;More N-S&quot;) # ) ) 3.8.1 Distribution of N-S Orientation Index all_groups_topo_fnl %&gt;% sf::st_set_geometry(NULL) %&gt;% ggplot( data = . , mapping = aes(x = north_south_orientation_index, group = group) ) + geom_histogram( aes(y = ..density.., fill = group) , bins = 50 , color = &quot;gray25&quot; ) + geom_vline( aes(xintercept = 0.5) , color = &quot;gray45&quot; , lwd = 0.8 ) + facet_grid(group~.) + scale_x_continuous(limits = c(-0.01, 1.01), breaks = scales::extended_breaks(n=10), labels = scales::comma) + scale_fill_manual(values = c(&quot;gray80&quot;, &quot;black&quot;)) + xlab(&quot;North-South Orientation Index&quot;) + ylab(&quot;Density&quot;) + labs( title = &quot;Group North-South Orientation Histogram&quot; , caption = &quot;&gt;0.5 = More N-S | &lt;0.5 = More E-W&quot; ) + theme_bw() + theme( legend.position = &quot;none&quot; , plot.caption = element_text(size = 7) ) 3.8.2 Counts by shape orientation and treatment group temp_dta &lt;- all_groups_topo_fnl %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(orientation_class) %&gt;% dplyr::summarise( n = n() ) %&gt;% dplyr::mutate(nlab = paste0(&quot;n=&quot;,n)) all_groups_topo_fnl %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(group, orientation_class) %&gt;% dplyr::summarise(n = n()) %&gt;% ggplot(.) + geom_bar(aes(x = orientation_class, y = n, fill = group, label = n) , stat = &quot;identity&quot;, width = 0.7) + geom_text(aes(x = orientation_class, y = n, fill = group, label = n) , size = 3, position = position_stack(vjust = 0.5), color = &quot;white&quot;) + geom_text(data = temp_dta , aes(x = orientation_class, y = n, label = n) , color = &quot;black&quot;, size = 4 , position = position_dodge(0.9) , vjust = -0.2 ) + labs( title = &quot;Count of treatment groups by shape orientation classification&quot; ) + xlab(&quot;Shape Orientation&quot;) + ylab(&quot;Count Groups&quot;) + scale_fill_manual(values = c(&quot;gray80&quot;, &quot;black&quot;)) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() ) The majority of group selection shapes have a square orientation with a length:width ratio ~1 (i.e. a north-south orientation index ~0.5). Groups classified as More E-W have a north-south orientation index &lt; 0.4. For example, if a square is drawn around the shape it will have a length:width (y-axis:x-axis) ratio of less than 2:3. Groups classified as More N-S have a north-south orientation index &gt; 0.6. For example, if a square is drawn around the shape it will have a length:width (y-axis:x-axis) ratio of at least 3:2. 3.9 Map Group Shape Orientation p_hli_fn &lt;- function(x){ # cts &lt;- seq(0, 1, length.out = 20) return( ggplot() + geom_sf( data = units , lwd = 0.8 , alpha = 0 , color = &quot;black&quot; ) + geom_sf( data = all_groups_topo_fnl %&gt;% dplyr::filter(group == x) # , aes(fill = cut(north_south_orientation_index, breaks = cts)) , aes(fill = orientation_class) , lwd = 0 ) + scale_fill_viridis_d(option = &quot;cividis&quot;, alpha = 0.9, drop = FALSE) + labs( title = paste(x, &quot;- Orientation of group shape&quot;) , subtitle = &quot;harvest treatment units in black&quot; , caption = &quot;More N-S = L:W &gt; 3:2 | More E-W = L:W &lt; 2:3&quot; ) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() # , plot.title = element_text(size = 8) , plot.subtitle = element_text(size = 7) , plot.caption = element_text(size = 7) ) ) } c(unique(all_groups_topo_fnl$group)) %&gt;% purrr::map(p_hli_fn) 3.10 Save Data sf::st_write(all_groups_topo_fnl, &quot;../data/all_groups_topo_fnl.gpkg&quot;, append = FALSE) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
